# -*- coding: utf-8 -*-
"""
Defines Callback functions for checking data format consistency between agents/tools.

Used with ADK's callback mechanism (e.g., before_tool_callback, after_tool_callback)
to validate data structures, types, and expected fields before or after tool execution.

Relevant ADK Classes:
- google.adk.agents.callback_context.CallbackContext: Provides context for agent-level callbacks.
- google.adk.tools.tool_context.ToolContext: Provides context for tool-level callbacks.
- google.adk.tools.base_tool.BaseTool: Represents the tool being called/finished.
- google.adk.models.llm_request.LlmRequest: Input to before_model_callback.
- google.adk.models.llm_response.LlmResponse: Input to after_model_callback, output from before_model_callback.
- typing.Dict, typing.Any, typing.Optional: For type hinting.
"""

from google.adk.agents.callback_context import CallbackContext
from google.adk.tools.tool_context import ToolContext
from google.adk.tools.base_tool import BaseTool
from google.adk.models.llm_response import LlmResponse
from typing import Optional, Dict, Any

# Placeholder for format checking callback functions

def check_tool_output_format(
    tool: BaseTool,
    result: Dict[str, Any], # The result dictionary returned by the tool
    tool_context: ToolContext
) -> Optional[Dict]:
    """
    Example after_tool_callback to check if a tool's output has required keys.

    Args:
        tool: The tool that just executed.
        result: The dictionary returned by the tool's execution.
        tool_context: Context object for the tool execution.

    Returns:
        The original result dictionary if format is okay, or a modified dictionary
        (e.g., with an added error flag) or None (to use original result).
        Returning a new dict replaces the original tool result.
    """
    print(f"--- Callback: check_tool_output_format running for tool '{tool.name}' ---")
    print(f"--- Callback: Inspecting result: {result} ---")

    # Example Check: Ensure a 'status' key exists
    if "status" not in result:
        error_msg = f"Tool '{tool.name}' output missing required 'status' key."
        print(f"--- Callback Warning: {error_msg} ---")
        # Option 1: Add an error flag to the result
        result["_format_error"] = error_msg
        # Option 2: Replace the result entirely (less common for format checks)
        # return {"status": "error", "error_message": error_msg, "_original_result": result}
        return result # Return modified original result

    # Add more checks based on tool name or expected output structure
    # if tool.name == "specific_tool_name":
    #     if "required_data_key" not in result.get("data", {}):
    #         # Handle missing nested key...

    print(f"--- Callback: Format check passed for tool '{tool.name}'. ---")
    return None # Returning None means use the original 'result' dictionary


def check_tool_input_args(
    tool: BaseTool,
    args: Dict[str, Any], # Arguments generated by LLM for the tool
    tool_context: ToolContext
) -> Optional[Dict]:
    """
    Example before_tool_callback to check if tool arguments meet basic requirements.

    Args:
        tool: The tool about to be executed.
        args: The arguments dictionary intended for the tool.
        tool_context: Context object for the tool execution.

    Returns:
        None if args are okay (tool proceeds), or a dictionary to block the tool
        and return this dict as the result instead.
    """
    print(f"--- Callback: check_tool_input_args running for tool '{tool.name}' ---")
    print(f"--- Callback: Inspecting args: {args} ---")

    # Example Check: Ensure a required argument exists for a specific tool
    if tool.name == "add_task_to_notion_database":
        if "task_name" not in args or not args["task_name"]:
            error_msg = f"Missing required argument 'task_name' for tool '{tool.name}'."
            print(f"--- Callback Error: {error_msg} Blocking tool call. ---")
            # Block the tool call by returning a result dictionary
            return {"status": "error", "error_message": error_msg}
        if "status" not in args or not args["status"]:
             error_msg = f"Missing required argument 'status' for tool '{tool.name}'."
             print(f"--- Callback Error: {error_msg} Blocking tool call. ---")
             return {"status": "error", "error_message": error_msg}

    # Add more checks (e.g., type checking, value validation)
    # if tool.name == "some_other_tool":
    #     if not isinstance(args.get("count"), int):
    #         # Handle type error...

    print(f"--- Callback: Input args check passed for tool '{tool.name}'. ---")
    return None # Allow tool execution to proceed

# --- Example Usage (how to assign in Agent definition) ---
# from google.adk.agents import LlmAgent
# my_agent = LlmAgent(
#     name="FormattedAgent",
#     model="gemini-2.0-flash",
#     tools=[some_tool_function],
#     before_tool_callback=check_tool_input_args,
#     after_tool_callback=check_tool_output_format,
#     # ... other params
# )
